# Generates a sample Birth-Death-Tree with nSpecies descendents conforming to birth and death
# rate lamda and mu, respectively with an assumed time tHeight since origin.
# The procedure uses the equality of the birth-death process with a point process as described in
# T. Gernhard, 'The conditioned reconstructed process', J. Theo. Biol. (2008) 253(4): 769-778
# reducing the generation of the tree to drawing nSpecies time points from an exponential distribution
BirthDeathTree := proc(lamda, mu, nSpecies, tHeight)
    specPoints := sort([seq(tHeight - invCDF(lamda, mu, Rand(), tHeight), nSpecies - 1)], x->-x):
    
    living := 1:
    tree := [seq(Leaf(string(i), tHeight), i=1..nSpecies)]:
    
    for i to nSpecies-1 do
        r := Rand(1..length(tree)-1):
        tree := [op(tree[1..r-1]), Tree(tree[r], specPoints[i], tree[r+1]), op(tree[r+2..-1])]:
    od:
    tree := op(tree):
end:


CDF := proc(lamda, mu, s, t) option internal;
    F := (1-exp(-(lamda-mu)*s))*(lamda-mu*exp(-(lamda-mu)*t)) / ((lamda-mu*exp(-(lamda-mu)*s))*(1-exp(-(lamda-mu)*t)))
end:


invCDF := proc(lamda, mu, r, t) option internal;
    c := (lamda - mu * exp(-(lamda - mu) * t))/(1 - exp(-(lamda - mu) * t));
    s := (ln(c - r * mu) - ln(c - r * lamda)) / (lamda - mu)
end:

FindDeepestLeaf := proc(tree:Tree)
    if type(tree, Leaf) then
        res := tree[Height]:
    else
        t1 := FindDeepestLeaf(tree[Left]):
        t2 := FindDeepestLeaf(tree[Right]):
        res := max(t1,t2):
    fi:
    res
end:

ScaleTreeHeight := proc(tree:Tree, factor:float, offset:float)
    tree[Height] := (tree[Height] - offset) * factor:
    if not type(tree, Leaf) then
        ScaleTreeHeight(tree[Left], factor, offset):
        ScaleTreeHeight(tree[Right], factor, offset):
    fi:
end:

ScaleTree := proc(tree:Tree, height:float)
    curh := FindDeepestLeaf(tree) - tree[Height]:
    hfac := height / curh:
    ScaleTreeHeight(tree, hfac, tree[Height]):
end:

ListTimePoints := proc(tree:Tree, prefix:string)
    if type(tree, Leaf) then
        res := copy([[],[]]):
    else
    	lt := ListTimePoints(tree[Left], prefix.'.1'):
    	rt := ListTimePoints(tree[Right], prefix.'.2'):
    	if length(tree) = 4 then
    		if tree[xtra][1] = 'S' then
	    		res := [[[prefix, tree[Height], tree[xtra][2]], op(lt[1]), op(rt[1])], [op(lt[2]), op(rt[2])]]:
	    	else
	    		res := [[op(lt[1]), op(rt[1])], [[prefix, tree[Height], tree[xtra][2]], op(lt[2]), op(rt[2])]]:
	    	fi:
   		else
	        res := [[[prefix, tree[Height]], op(lt[1]), op(rt[1])],[]]:
	    fi:
    fi:
    res
end:
    
EnumerateBranches := proc(tree:Tree, specPts)
	branches := append(EnumerateBranches_R(tree[Left], tree[Height]), op(EnumerateBranches_R(tree[Right], tree[Height]))):
	branches := sort(branches, x->x[1]):
	res := copy([[1, 0, specPts[1, 2]]]):
	n := 2:
	for i to length(specPts) do
		res := append(res, [specPts[i, 1], op(branches[2*i-1])], [n, op(branches[2*i])]):
		n := n + 1:
	od:
	res
end:

EnumerateBranches_R := proc(tree:Tree, start:nonnegative)
	if type(tree, Leaf) then return([[start, tree[Height]]]): fi:
	
	res := EnumerateBranches_R(tree[Left], tree[Height]):
	res := append(res, [start, tree[Height]], op(EnumerateBranches_R(tree[Right], tree[Height]))):
end:
