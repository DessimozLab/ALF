# Generates a sample Birth-Death-Tree with nSpecies descendents conforming to birth and death
# rate lamda and mu, respectively with an assumed time tHeight since origin.
# The procedure uses the equality of the birth-death process with a point process as described in
# T. Gernhard, 'The conditioned reconstructed process', J. Theo. Biol. (2008) 253(4): 769-778
# reducing the generation of the tree to drawing nSpecies time points from an exponential distribution
BirthDeathTree := proc(lamda, mu, nSpecies, tHeight)
    specPoints := sort([seq(tHeight - invCDF(lamda, mu, Rand(), tHeight), nSpecies - 1)], x->-x):
    
    living := 1:
    tree := [seq(Leaf('S'.i, tHeight), i=1..nSpecies)]:
    
    for i to nSpecies-1 do
        r := Rand(1..length(tree)-1):
        tree := [op(tree[1..r-1]), Tree(tree[r], specPoints[i], tree[r+1]), op(tree[r+2..-1])]:
    od:
    tree := op(tree):
end:


CDF := proc(lamda, mu, s, t) option internal;
    F := (1-exp(-(lamda-mu)*s))*(lamda-mu*exp(-(lamda-mu)*t)) / ((lamda-mu*exp(-(lamda-mu)*s))*(1-exp(-(lamda-mu)*t)))
end:


invCDF := proc(lamda, mu, r, t) option internal;
    c := (lamda - mu * exp(-(lamda - mu) * t))/(1 - exp(-(lamda - mu) * t));
    s := (ln(c - r * mu) - ln(c - r * lamda)) / (lamda - mu)
end:

FindDeepestLeaf := proc(tree:Tree)
    if type(tree, Leaf) then
        res := tree[Height]:
    else
        t1 := FindDeepestLeaf(tree[Left]):
        t2 := FindDeepestLeaf(tree[Right]):
        res := max(t1,t2):
    fi:
    res
end:

ScaleTreeHeight := proc(tree:Tree, factor:float, offset:float)
    tree[Height] := (tree[Height] - offset) * factor:
    if not type(tree, Leaf) then
        ScaleTreeHeight(tree[Left], factor, offset):
        ScaleTreeHeight(tree[Right], factor, offset):
    fi:
end:

ScaleTree := proc(tree:Tree, height:float)
    curh := FindDeepestLeaf(tree) - tree[Height]:
    hfac := height / curh:
    ScaleTreeHeight(tree, hfac, tree[Height]):
end:

ListTimePoints := proc(tree:Tree, prefix:string)
    if type(tree, Leaf) then
        res := copy([[],[]]):
    else
    	lt := ListTimePoints(tree[Left], prefix.'.1'):
    	rt := ListTimePoints(tree[Right], prefix.'.2'):
    	if length(tree) > 3 then
    		if tree[xtra][1] = 'S' then
	    		res := [[[prefix, tree[Height], tree[xtra][2]], op(lt[1]), op(rt[1])], [op(lt[2]), op(rt[2])]]:
	    	elif tree[xtra][1] = 'D' then
	    		res := [[op(lt[1]), op(rt[1])], [[prefix, tree[Height], tree[xtra][2]], op(lt[2]), op(rt[2])]]:
	        else
                res := [[[prefix, tree[Height]], op(lt[1]), op(rt[1])],[]]:
	    	fi:
   		else
	        res := [[[prefix, tree[Height]], op(lt[1]), op(rt[1])],[]]:
	    fi:
    fi:
    res
end:
    
EnumerateBranches := proc(tree:Tree, specPts, gc:boolean)
	branches := append(EnumerateBranches_R(tree[Left], tree[Height], gc), op(EnumerateBranches_R(tree[Right], tree[Height], gc))):
	branches := sort(branches, x->x[1]):
	if gc then
        res := copy([[1, 0, specPts[1, 2], tree[-1]]]):
    else
        res := copy([[1, 0, specPts[1, 2]]]):
    fi:
	n := 2:
	for i to length(specPts) do
		res := append(res, [specPts[i, 1], op(branches[2*i-1])], [n, op(branches[2*i])]):
		n := n + 1:
	od:
	res
end:

EnumerateBranches_R := proc(tree:Tree, start:nonnegative, gc:boolean)
	if type(tree, Leaf) then 
	    if gc then
	        return([[start, tree[Height], tree[-1]]]):
	    else
	        return([[start, tree[Height]]]):
	    fi:
	fi:
	res := EnumerateBranches_R(tree[Left], tree[Height], gc):
	if gc then
	    res := append(res, [start, tree[Height], tree[-1]], op(EnumerateBranches_R(tree[Right], tree[Height], gc))):
	else
	    res := append(res, [start, tree[Height]], op(EnumerateBranches_R(tree[Right], tree[Height], gc))):
	fi:
end:

# prevent branches of length 0 by adding a small value
CheckBranchLengths := proc(tree:Tree)
    CheckBranchLengths_R(tree, 0):
end:

CheckBranchLengths_R := proc(tree:Tree, inc:nonnegative) option internal;
    if type(tree, Leaf) then return() fi:

    linc := inc + If(tree[Height] = tree[Left][Height], 1e-10, 0):
    CheckBranchLengths_R(tree[Left], linc):
    tree[Left][Height] := tree[Left][Height] + linc:

    rinc := inc + If(tree[Height] = tree[Right][Height], 1e-10, 0):
    CheckBranchLengths_R(tree[Right], rinc):
    tree[Right][Height] := tree[Right][Height] + rinc:
end:

AddDeviation := proc(t:Tree)
    curh := FindDeepestLeaf(t) - t[Height]:
    mu := 0.2/(0.001+Rand()):

    # add deviation to tree
    AddDeviation_R(t, mu):
    
    # normalize tree
    newh := FindDeepestLeaf(t) - t[Height]:
    ScaleTreeHeight(t, curh / newh, t[Height]):
end:

AddDeviation_R := proc(t:Tree, mu:numeric) option internal;
    # left subtree
    x := Rand(Exponential(0,mu)):
    curblen := t[Left, Height] - t[Height]:
    newblen := (1+x) * curblen:
    PropagateDeviation(t[Left], newblen - curblen):
    if not type(t[Left], Leaf) then
        AddDeviation_R(t[Left], mu):
    fi:

    # right subtree
    x := Rand(Exponential(0,mu)):
    curblen := t[Right, Height] - t[Height]:
    newblen := (1+x) * curblen:
    PropagateDeviation(t[Right], newblen - curblen):
    if not type(t[Right], Leaf) then
        AddDeviation_R(t[Right], mu):
    fi:
end:

PropagateDeviation := proc(t:Tree, delta:numeric) option internal;
    t[Height] := t[Height] + delta:
    if not type(t, Leaf) then
        PropagateDeviation(t[Left], delta):
        PropagateDeviation(t[Right], delta):
    fi:
end:
