# procedures for Synthetic evolution
# Daniel Margadant, Sereina Riniker, CBRG, 2006
#

# CreateCodonMatrices();


########################################################################
# procedures for analyses and reports on EVA data


# counts L, Lo and D for a certain array of description strings
# needed for testM()
countEvents := proc(des:array)
    r := [];
    for i to length(des) do
        lo := length(SearchAllString('Lo', des[i]));
        l := length(SearchAllString('L', des[i])) - lo;
        d := length(SearchAllString('D', des[i]));
        r := append(r, [lo, l, d]);
    od;
    Result := r;
end:


# checks oma group for ortholog consitency, check for LGT and Paralogs
testM := proc(oma:posint)
    IDs := CreateArray(1..N);
    des := CreateArray(1..N);
    for i to N do
        if M[oma, i] = 0 then next; fi;
        DB := ReadDb(GenomeFileName[genomes[i]]);
        IDs[i] := parse(SearchTag('ID', Entry(M[oma, i])));
        des[i] := SearchTag('DE', Entry(M[oma, i]));
    od;
    s := {op(IDs)} minus {0}; s:=s[1];
    orthoFalse := [];
    printf('\n\noma[%i]\n\n', oma);
    for i to N do
        if M[oma, i] = 0 then next; fi;
        if IDs[i] = s then
            h := countEvents([des[i]]);
            printf('org: %i\tLo: %i  L: %i  D: %i\n', i, op(op(h)));
            orthoTrue := op(h);
        # a second id is present in oma
        else
            # check if id is present in another group (=paralog)
            paralog := false;
            for j to N do
                DB := ReadDb(GenomeFileName[genomes[j]]);
                for k to DB[TotEntries] do
                    if parse(SearchTag('ID', Entry(k))) = IDs[i] then
                        if SearchArray(k, transpose(M)[j]) > 0 and 
                            SearchArray(k, transpose(M)[j]) <> oma then
                            paralog := true;
                            oma2 := SearchArray(k, transpose(M)[j]); 
                        fi;
                     fi;
                 od;
            od;
            h := countEvents([des[i]]);
            if paralog = true then
                orthoFalse := append(orthoFalse, [i ,op(op(h))]);
                printf('org: %i\tLo: %i  L: %i  D: %i'.
                    '  orthologs also in M[%i]\n', i, op(op(h)), oma2);
            else
                printf('org: %i\tLo: %i  L: %i  D: %i\n', i, op(op(h)));
            fi;
        fi;
    od;
    for i to length(orthoFalse) do
        orthoFalse[i] := [orthoFalse[i, 1],
            op(orthoFalse[i][2..4] - orthoTrue)];
    od;
    Result := orthoFalse;
end:


# gives a summary of all organism and their numbers of proteins,
# LGTs and duplications, argument must be 'a' for array or 'r' for report
# !!! obsolete! (does not work on new data structure)
lgtReport := proc(a: string)
    summary := CreateArray(1..N,1..6);
    prot := Stat('Proteins'); lgt := Stat('LGT');
    lgtnum := Stat('LGTNum');
    dup := Stat('Dupl'); dupnum := Stat('DuplNum');
    for i to N do
        summary[i,1] := genomes[i];	
        summary[i,2] := GS[genomes[i]][TotEntries];	
        prot + summary[i][2];	
        summary[i,3] := GS[genomes[i]][TotLGT]; 
        lgt + summary[i,3];
        summary[i,4] := GS[genomes[i]][TotLGTNum]; 
        lgtnum + summary[i,4];
        summary[i,5] := GS[genomes[i]][TotDupl]; 
        dup + summary[i,5];	
        summary[i,6] := GS[genomes[i]][TotDupNum]; 
        dupnum + summary[i,6];	
    od;
    if a = 'a' then		
        result := summary;
    elif a = 'r' then
	printf('genomes\tproteins\tlgt\t\tlgt total\tdupl\t\tdupl total\n\n');
	for i to N do
	    printf('%s\t\t%i\t\t%i (%.2f%%)\t%i (%.2f%%)\t%i (%.2f%%)\t'.
            '%i (%.2f%%)\n', summary[i][1],summary[i][2],summary[i][3],
            (summary[i][3]/summary[i][2]*100),summary[i][4],
            (summary[i][4]/summary[i][2]*100),summary[i][5],
            (summary[i][5]/summary[i][2]*100),summary[i][6],
            (summary[i][6]/summary[i][2]*100));
	od;
	printf('\naverages\t%.0f\t\t%.0f (%.2f%%)\t%.0f (%.2f%%)\t'.
        '%.0f (%.2f%%)\t%.0f (%.2f%%)\n', prot[Average], lgt[Average], 
        (lgt[Average] / prot[Average] * 100), lgtnum[Average], 
        (lgtnum[Average] / prot[Average]*100), dup[Average], 
        (dup[Average] / prot[Average] * 100), dupnum[Average], 
        (dupnum[Average] / prot[Average] * 100));
	printf('mean var\t%s\t%s\t\t\t %s\n', 
        prot[MeanVar],lgt[MeanVar],dup[MeanVar]);
    else 
        printf('wrong argument, must be a or r');
    fi;
end: 


# gives a report of the ID numbers for an OMA group
lgtM := proc(omanum: posint)	# omanum = OMA number for the report
    filepattern := 'DB/SE';
    ids := CreateArray(1..N);
    for b to N do
	ids[b] := '';
    od;
    for i to N do
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	if M[omanum, i] = 0 then 
	    ids[i] := '0';
	    next;
	else
	    e := Entry(M[omanum,i]);
	    de := SearchTag('DE', e);
	    posL := SearchString('L', de);
	    posD := SearchString('D', de);
	    # first event was a dupl
	    if posD > -1 and (posL > posD or posL = -1) then
	    	n := posD;
           	while de[n] <> '(' do	# searches for ID number
		    n := n-1;
            	od;
                for k from (n+1) to posD do   # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	# how many dupl and LGT occurred
                    if de[j] = 'L' then
			if de[j+1] = 'o' then
			    ids[i] := string(ids[i]).'Lo';
			else 
			    ids[i] := string(ids[i]).'L';
			fi;
                    elif de[j] = 'D' then ids[i] := string(ids[i]).'D';
                    fi;
                od;
	    # first event was a LGT
	    elif posL > -1 and (posD > posL or posD = -1) then
	        n := posL;
                while de[n] <> '(' do	# searches for ID number
                    n := n-1;
                od;
                for k from (n+1) to posL do  # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	#  how many dupl and LGT  occured
                    if de[j] = 'L' then 
			if de[j+1] = 'o' then
                            ids[i] := string(ids[i]).'Lo';
                        else
                            ids[i] := string(ids[i]).'L';
                        fi;
                    elif de[j] = 'D' then ids[i] := ids[i].'D';
                    fi;
                od;
	    # if no LGT or duplication has occured
	    else ids[i] := SearchTag('ID', e); 
	    fi;
	fi;
    od;
    for j to N do
	printf('%s\t', genomes[j]);
    od;
    printf('\n');
    for k to N do
	printf('%s\t', string(ids[k]));
    od;
    printf('\n');
end:


# checks set of OMA number if LGT was present and gives nice summary
# useful for lgt algorithm test, 15.12.06/dm
lgtMcheck := proc(liste: set)
    realLGT := lgtGroups();	
    lgtTrue := liste intersect realLGT;
    lgtWrong := liste minus realLGT;
    lgtUnfound := realLGT minus liste;
    printf('\n\ncorrect groups:\t%i\t%.2f%%\n', length(lgtTrue),
        (length(lgtTrue) / length(realLGT) * 100));
    printf('false groups:\t%i\t%.2f%%\n', length(lgtWrong),
        (length(lgtWrong) / length(realLGT) * 100));
    printf('missed groups:\t%i\t%.2f%%\n\n', length(lgtUnfound),
        (length(lgtUnfound) / length(realLGT) * 100));
    printf('sensitivity:\t\t%.2f%%\n', length(lgtTrue) / length(realLGT) * 100);
    printf('specifity:\t\t%.2f%%\n\n', length(lgtTrue) / length(liste) * 100);
    printf('correct ones:\n%a\n', lgtTrue);
    printf('wrong ones:\n%a\n', lgtWrong);
    printf('missed ones:\n%a\n', lgtUnfound);
end:


# gives set of OMA groups in which lgt event had taken place, 15.12.06
lgtGroups := proc()
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('L', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i); 
	        fi;
	    od;	
    od;
    result := r;
end:


# gives set of OMA groups in which lgt event (orthologous replacement) had 
# taken place, 15.12.06
lgtGroupsLo := proc()
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('Lo', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i);
            fi;
        od;
    od;
    result := r;
end:

# gives array with entry and ID number of an organism in the real order
# the organism is the argument (e.g. SE001)
getGenomeOrder := proc(org:string)
    DB := ReadDb(GenomeFileName[org]);
    geneR := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        e := Entry(i);
        loc := SearchTag('LOC', e);
        geneR[parse(loc)] := [i, SearchTag('ID', e)];   # Entry and ID number
    od;
    result := geneR;
end:

# gives array with all orthologues between two organisms as entry numbers
# arguments are the organisms (e.g. SE001)
getOrthoSet := proc(org1:string, org2:string)
    orthoSet := [];
    DB := ReadDb(GenomeFileName[org1]);
    ortho1 := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        ortho1[i] := SearchTag('ID', Entry(i));
    od;
    DB := ReadDb(GenomeFileName[org2]);
    ortho2 := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        ortho2[i] := SearchTag('ID', Entry(i));
    od;    
    all1 := copy(ortho1);
    all2 := copy(ortho2);
    ortho1 := {op(ortho1)};
    ortho2 := {op(ortho2)};
    a := ortho1 intersect ortho2;
    for i in a do
        orthoSet := append(orthoSet, [SearchArray(i, all1), SearchArray(i, all2)]);
    od;
    result := orthoSet;
end:

########################################################################
# internal procedures for data creation


# mutates organisms for a certain amount of time steps, 15.12.06
seqmutation := proc(org: posint, ts: posint)
    global evolution, substModels;
    for k to length(evolution[org]) do
        oldLen := length(evolution[org,k,2]):
        #printf('seqmutation %d/%d domains: %a\n', org,k,evolution[org,k,1]):
        substModel := substModels[evolution[org, k, 9]]:
        # apply rate modifications from duplications
        rateFac := ts:
        for i from length(evolution[org,k,10]) to 1 by -1 do
            rateFac := rateFac * evolution[org,k,10,i,2]:
            # remove rate modifier if it exceeds its lifetime
            if evolution[org,k,10,i,1] <= evolTime then
                [op(evolution[org,k,10,1..i-1]), op(evolution[org,k,10,i+1..-1])]:
            fi:
        od:
        # compute CodonMatrix from GC target content
        if substModel[Type] <> 'aa' then
                GCMatrix := substModel[LogPAM1]:
            if enableGCAmelioration then
                if substModel[Name][1] = 'M' then
                    GCMatrix := CreateArray(1..length(substModel[LogPAM1]),0):
                    for i to length(YCodonLogPAM1) do
                        GCMatrix[i] := GCBiasMatrix(GCratio[org], substModel[LogPAM1][i], substModel[Type]):
                    od:
                else
                    GCMatrix := GCBiasMatrix(GCratio[org], GCMatrix, substModel[Type]):
                fi:
            fi:
        fi:
        seqTot := '';
        # loop over all domains for protein k
        for i to length(evolution[org, k, 1]) do
            if substModel[Type] = 'aa' then
                sequence := evolution[org, k, 2][(evolution[org, k, 1][i, 1])..evolution[org, k, 1][i, 2]];
                # TODO: mutate amino acid sequence
                if type(evolution[org,k,1][i,3], list) then
                    #printf('length: %d\n', length(sequence)):
                    sequence := AAMutateGamma(sequence, rateFac * gammaRates, evolution[org, k, 1][i,3]):
                    #printf('length: %d\n', length(sequence)):
                else
                    sequence := Mutate(sequence, rateFac * evolution[org, k, 1][i,3]):
                fi:
            else
                if substModel[Blocksize] = 3 then
                    sequence := evolution[org, k, 6][(evolution[org, k, 1][i, 1]
                        * 3 - 2)..evolution[org, k, 1][i, 2] * 3];
                else
                    sequence := evolution[org, k, 6][evolution[org, k, 1][i, 1]..evolution[org, k, 1][i, 2]];
                fi:
                if substModel[Type] = 'nuc' then
                    if type(evolution[org,k,1][i,3], list) then
                        sequence := NucleotideMutate(sequence, rateFac * gammaRates, GCMatrix, evolution[org, k, 1][i,3]):
                    else
                        sequence := NucleotideMutate(sequence, rateFac * evolution[org, k, 1][i, 3], GCMatrix):
                    fi:
                else
                    if type(evolution[org,k,1][i,3], list) then
                        if substModel[Name][1] = 'M' then
                            sequence := CodonMutate(sequence, rateFac, GCMatrix, evolution[org, k, 1][i,3]):
                        else
                            ol := length(sequence):
                            sequence := CodonMutate(sequence, rateFac * gammaRates, GCMatrix, evolution[org, k, 1][i,3]):
                            if ol <> length(sequence) then
                                printf('ERROR occurred in CodonMutate!\n'):
                            fi:
                        fi:
                    else
                        sequence := CodonMutate(sequence, rateFac * evolution[org, k, 1][i,3], GCMatrix):
                    fi:
                fi:
            fi:
            seqTot := seqTot.string(sequence);
        od;
        if substModel[Type] = 'aa' then
            evolution[org, k, 2] := string(seqTot):
        else
            evolution[org, k, 6] := string(seqTot);
            if substModel[Blocksize] = 3 then
                evolution[org, k, 2] := ProteinSeq(evolution[org, k, 6]);
            fi:
        fi:
        if oldLen <> length(evolution[org,k,2]) then
            printf('error mutating gene %d of org %d\n', k, org):
        fi:
    od;
end:

NBNormalizationFactor := proc(maxLen, r, q)
    res := 0:
    for L to maxLen do
        res := res + ((r+L-2)!/((L-1)!*(r+1)!)*(1-q)^r*q^(L-1)):
    od:
    res
end:

QGNormalizationFactor := proc(maxLen, c, t)
    res := 0:
    for i to maxLen do
        res := res + 1.027e-2*exp(-i*c/(0.96*t)) + 3.031e-3*exp(-i*c/(3.13*t))
                   + 6.141e-4*exp(-i*c/(14.3*t)) + 2.090e-5*exp(-i*c/(81.7*t)):
    od:
    res
end:

ZipfNormalizationFactor := proc(maxLen, c)
    res := 0:
    for i to maxLen do
        res := res + i^(-c):
    od:
    res
end:

GQG := proc(n, c, t)
    fac := QGNormalizationFactor(100, c, t):
    res :=  (1.027e-2*exp(-n*c/(0.96*t)) + 3.031e-3*exp(-n*c/(3.13*t))
                   + 6.141e-4*exp(-n*c/(14.3*t)) + 2.090e-5*exp(-n*c/(81.7*t))) / fac:
end:

randGapLength := proc(maxLen:nonnegative, indelType:{'ZIPF', 'QG', 'NEGBIN', 'CUSTOM'} ; params:list(numeric))
    L := 0; s := 0;
    rp := Rand();
    if indelType = 'ZIPF' then
        normFactor := ZipfNormalizationFactor(maxLen, params[1]):
        while s < rp and L < maxLen do
            L := L + 1;
            s := s + L^(-params[1]) / normFactor;
        od;
    elif indelType = 'QG' then
        # params should have the form [QG_c, QG_t]
        normFactor := QGNormalizationFactor(maxLen, params[1], params[2]):
        c := params[1]: t := params[2]:
        while s < rp and L < maxLen do
            L := L + 1:
            s := s + (1.027e-2*exp(-L*c/(0.96*t)) + 3.031e-3*exp(-L*c/(3.13*t))
                   + 6.141e-4*exp(-L*c/(14.3*t)) + 2.090e-5*exp(-L*c/(81.7*t))) / normFactor:
        od:
    elif indelType = 'NEGBIN' then
        # params should have the form [NB_r, NB_q]
        if not type(params[1], posint) or not (type(params[2], nonnegative) and params[2] <= 1) then
            printf('parameters for negative binomial distribution do not match!'):
        fi:
        r := params[1]: q := params[2]:
        normFactor := NBNormalizationFactor(maxLen, r, q):
        while s < rp and L < maxLen do
            L := L + 1:
            s := s + ((r+L-2)!/((L-1)!*(r+1)!)*(1-q)^r*q^(L-1))/normFactor:
        od:
    else
        # param[i] should contain the probability of a gap of length i from the custom distribution
        if length(params) <> maxLen then
            error('length of array of gap length probabilities must match the maximum gap length!'):
        fi:
        while s < rp and L < maxLen do
            L := L + 1:
            s := s + params[L]:
        od:
    fi:
    L
end:


# tranlates DNA to Protein (by Alexander Roth, CBRG)
ProteinSeq := proc(dna:string)
    prot := '';
    for i to length(dna) by 3 do
        prot := prot.CodonToA(dna[i..i + 2]);
    od;
    if length(prot) > 0 and prot[-1] = '$' then
        prot := prot[1..-2]:
    fi:
    prot
end:


# gives an array with the names of the pairs for LGT
LGTpairs := proc(omanum: integer, spec:array)
    a := 1;
    b := lM;
    if omanum > 0 then
	a := omanum;
	b := omanum;
    fi;
    LGTrec := [];
    filepattern := 'DB/SE';    
    for i from 1 to N do        
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	for j from a to b do
	    if M[j,i] <> 0 then
		e := Entry(M[j,i]);
		de := SearchTag('DE', e);
		for k from 1 to length(de) do
		    donor := '': rec := '': time:=''; gene:='';
		    if de[k] = 'L' then
			n := k;
			while de[n] <> '-' do
			    n := n-1;
			od;
			n := n+1;
			while de[n] <> '(' do
			    donor := string(donor).string(de[n]);
			    n := n+1;
			od;
			n := n+1;
			while n <k do
			    gene := string(gene).string(de[n]);
			    n := n+1;
			od;
			if de[k+1] = 'o' then
			    n:= k+2;
			else
			    n := k+1;
			fi;
			while de[n] <> ')' do
			    time := string(time).string(de[n]);
			    n := n+1;
                        od;
			n := n+1;
                        while de[n] <> '-' and n < length(de) do
                            rec := string(rec).string(de[n]);
			    n := n+1;
                        od;
			if n = length(de) then
			    rec := string(rec).string(de[n]);
			fi;
			LGTrec := append(LGTrec, [genomes[parse(donor)],
			    genomes[parse(rec)],time, gene]);
		    fi;
		od;
	    fi;
	od;
    od;
    LGTrec := {op(LGTrec)};
    LGTpairs := CreateArray(1..length(LGTrec), 1..3);
    for i to length(LGTrec) do
	j := 1;
	while parse(LGTrec[i,3]) > parse(spec[j,3]) and (j+1) <= length(spec) do
	    j := j + 1;
	od;
	LGTpairs[i,1] := LGTrec[i,1];
	LGTpairs[i,2] := LGTrec[i,2];
	LGTpairs[i,3] := LGTrec[i,4].'-'.LGTrec[i,3];
	if i <> length(spec) then
	    searchSpec(i, j, LGTrec[i,1], 1, spec, LGTpairs);
	    searchSpec(i, j, LGTrec[i,2], 2, spec, LGTpairs);
	fi;
    od;
    result := LGTpairs;
end:


# searches the tree for children of the LGT parents
searchSpec := proc(i: posint, j: posint, org: string, pos: posint, spec:array, LGTpairs:array)
    for k from j to length(spec) do
	if org = spec[k,1] then
		LGTpairs[i,pos] := [op(LGTpairs[i,pos]),spec[k,2]];
	    for a from k to length(spec) do
		if spec[k,2] = spec[a,1] then
		    searchSpec(i, a, spec[k,2], pos, spec, LGTpairs);
		fi;
	    od;
	fi;                
    od;
end:


# calculates the GC content for the genome of a given organism, 15.12.06
calGCcont := proc(org)
    sumGC := 0;
    for i to length(org) do
        if substModels[org[i,9]][Type] <> 'aa' then
            cont := BaseCount(org[i, 6]);
            sumGC := sumGC + ((cont[2] + cont[3]) / sum(cont[1..4]));
        fi:
    od;
    return (sumGC / length(org) * 100);
end:


# generates a CodonMatrix for GC amelioration (by adrian schneider)
# adapted by daniel dalquen to compute a CodonMatrix based on a target
# GC content (the bias for the matrix is computed from the target content
# using a polynomial fit over the empirical convergence values)
GCBiasMatrix := proc(gccont:numeric;(lnM1=CodonLogPAM1):matrix, simType:string)
    M1 := exp(lnM1);
    if simType = 'codon' then
        # compute the actual bias
        bias := 5.46135*gccont^3 - 4.53971*gccont^2 + 2.7788*gccont - .92313:
        GC := CreateArray(1..64):
        for i to 64 do
            t := BaseCount(CIntToCodon(i));
            GC[i] := t[2]+t[3];
        od;
        matlen := 64:
    elif simType = 'nuc' then
        bias := 5.11693*gccont^3 - 4.74833*gccont^2 + 2.97291*gccont - .91322:
        GC := [seq(If(NIntToNuc(i) = 'C' or NIntToNuc(i) = 'G', 1, 0), i=1..4)]:
        matlen := 4:
    else
        error('gc amelioration only works for dna and codon simulations'):
    fi:
    f := 1+bias;
    for i to matlen do for j to matlen do M1[i,j] := max(0,M1[i,j]) od od:
    for i to matlen do  # mutation from i to j
        for j to matlen do
            if j=i then next fi;
            d := GC[j]-GC[i];
            M1[j,i] := M1[j,i]*f^d;
        od;
        s := sum(M1[j,i],j=1..matlen)-M1[i,i];
        if s<0 or s>1 then error('invalid sum') fi;
        M1[i,i] := 1-s;
    od:
    return(ln(M1));
end:


makeAreasOmega := proc(substModel:string, aaStart:posint; classFreq:{nonnegative, list(nonnegative)})
        domains := copy([[1, aaStart, 0]]):
        domains[1,3] := CreateArray(1..aaStart, 1):
    if substModel = 'M0' then
        return(domains):
    elif substModel = 'M2' or substModel = 'M3' then
        cdf := CreateArray(1..length(classFreq)+1, 0):
        cdf[1] := classFreq[1]:
        for i from 2 to length(classFreq) do
            cdf[i] := cdf[i-1] + classFreq[i]:
        od:
        cdf[length(classFreq)+1] := 1:
    elif substModel = 'M8' then
        cdf := [seq(i*(1-classFreq)/10, i=1..10)]:
        cdf := append(cdf, 1):
    fi:
    for i to aaStart do
        r := Rand():
        for j to length(cdf) do
            if r <= cdf[j] then
                domains[1,3,i] := j:
                break:
            fi:
        od:
    od:
    return(domains):
end:
        
        

# makes the areas for rate heterogenity in a gene
makeAreas := proc(aaStart, areas, mutRate, maxSteps, distr:{'Poisson', 'Gamma'}; motFreq:nonnegative)
    if distr = 'Poisson' then
        if not assigned(motFreq) then
            motFreq := 0:
        fi:
        domains := CreateArray(1..Rand(1..areas));
        numEnt := {};
        for i to (length(domains) - 1) do
            num1 := round(aaStart / (length(domains) - 1));
            limitlow := max(1, ((i - 1) * num1 + 1));
            limithigh := min(aaStart - 1, (i * num1 - 1));
            numEnt := append(numEnt, Rand(limitlow..limithigh));
        od;    
        numEnt := append(numEnt, 0);
        numEnt := append(numEnt, aaStart);
        for i to length(domains) do        
            domains[i] := [(numEnt[i]+1), numEnt[i+1], 
                If(Rand() < motFreq, 1/DBL_MAX, Rand(Poisson(mutRate)) / maxSteps)];
        od;
    else
        if not assigned(motFreq) then
            error ('gamma distribution requires alpha parameter')
        fi:
        motifs := {}:
        for i to aaStart do
            if Rand() <= motFreq then
                motifs := append(motifs,i):
            fi:
        od:
        #printf('%a\n', motifs):
        if length(motifs) = 0 then
            domains := []:
            domains := append(domains, [1, aaStart, [seq(Rand(1..areas), aaStart)]]):
        else
            domains := CreateArray(1..2*length(motifs)-1):
            d := {}:
            for i to length(domains) do
                if floor(i/2) <> i/2 then # handle motif
                    domains[i] := [motifs[ceil(i/2)], motifs[ceil(i/2)], 1/DBL_MAX]:
                else # handle gamma domain
                    domains[i] := [motifs[i/2]+1, motifs[i/2+1]-1, []]:
                    if domains[i,1] > domains[i,2] then # domain is empty (2 motifs next to each other)
                        d := append(d,i):
                        next:
                    fi:
                    #for j to domains[i,2]-domains[i,1]+1 do
                    #    rnd := Rand(1..areas):
                    #domains[i,3] := append(domains[i,3], gr[rnd]):
                    #od:
                    # for gamma rates we only store the class not the actual rate
                    domains[i,3] := [seq(Rand(1..areas), domains[i,2]-domains[i,1]+1)]:
                fi:
            od:
            if d <> {} then
                for i from length(d) to 1 by -1 do
                    domains := [op(domains[1..d[i]-1]), op(domains[d[i]+1..-1])]:
                od:
            fi:
            if motifs[1] <> 1 then
                domains := append([[1, motifs[1]-1, [seq(Rand(1..areas), domains[1,1]-1)]]], op(domains)):
                #for j to domains[1,2]-domains[1,1]+1 do
                #    rnd := Rand(1..areas):
                #    domains[1,3] := append(domains[1,3], gr[rnd]):
                #od:
            fi:
            if motifs[-1] <> aaStart then
                domains := append(domains, [motifs[-1]+1, aaStart, [seq(Rand(1..areas), aaStart-domains[-1,2])]]):
                #for j to domains[-1,2]-domains[-1,1]+1 do
                #    rnd := Rand(1..areas):
                #    domains[-1,3] := append(domains[-1,3], gr[rnd]):
                #od:
            fi:
        fi:
    fi:
    return(domains);
end:

updateBorderOmega := proc(substModel:string, domain:array, value, len, event, classFreq:{nonnegative, list(nonnegative)})
    oldmax := max(domain[3]):
    #printf('classes of domain(max %d): %a\n', oldmax, domain[3]):
    dom := domain:
    if event = 'insert' then
        dom[2] := dom[2] + len:
        if substModel = 'M0' then
            return(dom):
        elif substModel = 'M2' or substModel = 'M3' then
            cdf := CreateArray(1..length(classFreq)+1, 0):
            cdf[1] := classFreq[1]:
            for i from 2 to length(classFreq) do
                cdf[i] := cdf[i-1] + classFreq[i]:
            od:
            cdf[length(classFreq)+1] := 1:
        elif substModel = 'M8' then
            cdf := [seq(i*(1-classFreq)/10, i=1..10)]:
            cdf := append(cdf, 1):
        fi:
        #printf('cdf: %a\n', cdf):
        ins := []:
        for i to len do
            r := Rand():
            for j to length(cdf) do
                if r < cdf[j] then ins := append(ins, j): break: fi:
            od:
            #if i <> length(ins) then printf('error in for loop\n') fi:
        od:
        dom[3] := [op(dom[3,1..value]), op(ins), op(dom[3, value+1..-1])]:
    else
        if substModel <> 'M0' then
            dom[3] := [op(dom[3,1..value-1]), op(dom[3,value+len..-1])]:
        fi:
        dom[2] := dom[2] - len:
    fi:
    #if max(dom[2]) <> length(dom[3]) then printf('length does not match: %d vs %d classes\n', dom[2], length(dom[3])): fi:
    dom
end:


# updates the area borders after a AA gain or loss
updateBorder := proc(domains: array, dom, value, len, event: string; (gamma=false):boolean, areas: nonnegative)
    global motifFreq;
    doms := domains:
    d := {};
    if event = 'insert' then    
        if gamma then
            relVal := value - doms[dom,1] + 1:
            newClasses := CreateArray(1..len,0):
            for i to len do
                if Rand() <= motifFreq then
                    newClasses[i] := areas+1:
                else
                    newClasses[i] := Rand(1..areas):
                fi:
            od:
            doms[dom,3] := [op(doms[dom,3,1..relVal]), op(newClasses), op(doms[dom,3,relVal+1..-1])]:
        fi:
        if doms[dom,1] = 0 then doms[dom,1] := 1: fi:
        for i from dom to length(doms) do
            if i > dom then
                doms[i,1] := (doms[i,1] + len);
            fi;
            doms[i,2] := (doms[i,2] + len);
        od;
    fi:
    if event = 'delet' then
        leng := len:
        val := value:
        i := dom:
        do
            curDomainLen := doms[i,2] - val + 1:
            if curDomainLen >= leng then
                if gamma then
                    relVal := val - doms[dom,1] + 1:
                    doms[i,3] := [op(doms[i,3,1..relVal-1]), op(doms[i,3,relVal+leng..-1])];
                fi:
                doms[i,2] := doms[i,2] - leng:
                curGapLen := leng:
            else
                if gamma then
                    relVal := val - doms[dom,1] + 1:
                    doms[i,3] := doms[i,3,1..relVal-1]:
                fi:
                doms[i,2] := val - 1:
                curGapLen := curDomainLen:
            fi:
            for j from i+1 to length(doms) do
                doms[j,1] := doms[j,1] - curGapLen:
                doms[j,2] := doms[j,2] - curGapLen:
            od:
            if doms[i,1] > doms[i,2] then
                d := append(d, i):
            fi:
            leng := leng - curDomainLen:
            if leng <= 0 then break fi:
            i := i + 1:
            val := doms[i,1]:
        od:
    fi;
    # deletes empty domain 
    for i from length(d) to 1 by -1 do
        if d[i] = 1 then doms[1,1] := doms[1,2] := 0: next fi:
        doms := [op(doms[1..d[i] - 1]), op(doms[d[i] + 1..-1])];
    od:
    return(doms);
end:


ComputeIndelPos := proc(e, sms, gr)
    # calculates sum of all domain/gene probabilities
    indelSum := indelPos := 0;
    for k to length(e) do
        substModel := sms[e[k,9]]:
        if substModel[Name][1] = 'M' then
            #handle M-series models
            # rate is hidden in the Q-matrices
            indelSum := indelSum + 1:
        elif rateDistribution = 'Gamma' then
            # handle gamma model
            for m to length(e[k, 1]) do
                if type(e[k, 1, m, 3], list) then
                    for mm to length(e[k, 1, m, 3]) do
                        indelSum := indelSum + gr[e[k, 1, m, 3, mm]]:
                    od:
                else
                    indelSum := indelSum + e[k, 1, m, 3]:
                fi:
            od:
        else
            for m to length(e[k, 1]) do
                indelSum := indelSum + e[k, 1, m, 3] * (1 + e[k, 1, m, 2] - e[k, 1, m, 1]);
            od;
        fi:
    od;
    # assignes a random value between 0..indelSum
    indelPos := Rand() * indelSum
end:


lprint('Procedures for Synthetic Evolution sucessfully loaded');
