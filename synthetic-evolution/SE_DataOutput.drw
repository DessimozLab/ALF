# Function to load a matrix file in PAML compatible format. Creates a 1-PAM matrix and assigns it
# to the global variables NewLogPAM1 and logPAM1
# it is assumed that the order of amino acids and codons is always the same and the matrix is
# re-ordered to correspond to the order used by Darwin.
LoadPAMLMatrixFile := proc(file:string, mtype:{'Peptide', 'Codon'})
    global AF, logPAM1, CodonLogPAM1, NewLogPAM1;
    if mtype = 'Peptide' then
        size := 20:
        SA := [A,  R,  N,  D,  C,  Q,  E,  G,  H,  I,  L,  K,  M,  F,  P,  S,  T,  W,  Y,  V]:
        convfunc := AToInt;
    elif mtype = 'Codon' then
        size := 64:
        SA := [TTT, TTC, TTA, TTG, TCT, TCC, TCA, TCG, TAT, TAC, TGT, TGC, TGG, CTT, CTC, CTA, CTG, CCT, CCC, CCA, 
        CCG, CAT, CAC, CAA, CAG, CGT, CGC, CGA, CGG, ATT, ATC, ATA, ATG, ACT, ACC, ACA, ACG, AAT, AAC, AAA, 
        AAG, AGT, AGC, AGA, AGG, GTT, GTC, GTA, GTG, GCT, GCC, GCA, GCG, GAT, GAC, GAA, GAG, GGT, GGC, GGA, 
        GGG, TAA, TAG, TGA]:
        convfunc := CodonToCInt;
    else
        error('could not determine size'):
    fi:
    
    # parse PAML matrix file format
    OpenReading(file):
    matrix := CreateArray(1..size, 1..size, 0):
    freqs := CreateArray(1..size, 0):
    command := copy('tmpmat := [[], ['):
    
    l := ReadRawLine():
    while l <> EOF and (l = '\n' or l = '\r' or l = '\r\n') do l := ReadRawLine() od:
    if l = EOF then error('unexpected end of file') fi:

    # parse matrix
    do
        tokens := SearchDelim(' ', l[1..-2]):
        for i to length(tokens) do
            if tokens[i] <> '' and tokens[i] <> '\n' and tokens[i] <> '\r' then command := command.tokens[i].', ' fi:
        od:
        while {command[-1]} intersect {' ', ',', '\r', '\n', '\t'} <> {} do command := command[1..-2]: od:
        l := ReadRawLine():
        if l <> '\n' and l <> '\r' and l <> '\r\n' then
            command := command.'], [':
        else
            command := command.']]:':
            break:
        fi:
    od:
    eval(parse(command)):
    if mtype = 'Peptide' and length(tmpmat) <> 20 then error('matrix should have 20 entries'):
    elif mtype = 'Codon' and length(tmpmat) <> 61 then error('matrix should have 61 entries'):
    fi:
    
    command := copy('tmpfreqs := ['):
    while l <> EOF and (l = '\n' or l = '\r' or l = '\r\n') do l := ReadRawLine() od:
    if l = EOF then error('unexpected end of file') fi:

    tokens := SearchDelim(' ', l):
    for i to length(tokens) do
        if tokens[i] <> '' and tokens[i] <> '\n' and tokens[i] <> '\r' then command := command.tokens[i].', ' fi:
    od:
    while {command[-1]} intersect {' ', ',', '\r', '\n', '\t'} <> {} do command := command[1..-2]: od:
    command := command.']:':
    eval(parse(command)):
    while l <> EOF  do l := ReadRawLine() od:

    if length(tmpfreqs) <> length(tmpmat) then error('matrix size doesn''t match frequency vector') fi:
    
    for i from 1 to length(tmpfreqs) do
        ai := convfunc(SA[i]):
        freqs[ai] := tmpfreqs[i]:
        for j from 1 to i-1 do
            aj := convfunc(SA[j]):
            matrix[ai,aj] := tmpmat[i,j]*tmpfreqs[j]:
            matrix[aj,ai] := tmpmat[i,j]*tmpfreqs[i]:
        od:
    od:
        
    freqmat := CreateArray(1..size,1..size,0):
    for i to size do
        freqmat[i,i] := freqs[i]:
    od:
    qsum := sum(sum(freqmat*matrix)):
        
    matrix := matrix/qsum:
    
    for i to size do
        v := 0:
        for j to size do
           if i <> j then
               v := v+matrix[i,j]:
            fi:
        od:
        matrix[i,i] := -v:
    od:
    freqs := freqs/sum(freqs):
    if mtype = 'Codon' then
        CreateCodonMatrices(transpose(matrix), freqs):
    else
        AF := freqs:
        M := exp(matrix);
        logPAM1 := matrix;
        n := length(AF):
        do  d := sum( AF[i]*(1-M[i,i]), i=1..n );
            if |d-0.01| < DBL_EPSILON then break fi;
            logPAM1 := logPAM1 * 0.01/d;
            M := exp(logPAM1)
        od;
        NewLogPAM1 := logPAM1:
    fi:
end:


# DB output
# 11.12.06/dm
DBout := proc()
    if length(FileStat(wdir.dbdir)) = 0 then
        TimedCallSystem('mkdir -p '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        # header output
        orgname := sprintf('SE%03d', i);
        OpenWriting(wdir.dbdir.orgname.'.db');
        printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
        printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
        printf('<SOURCE>sequence simulation</SOURCE>\n');
        printf('<DATE>%s</DATE>\n', date());
        printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
        printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
        printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
        printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
            'Organismus syntheticus_%s</OS>\n', orgname);
        printf('<KINGDOM>Bacteria</KINGDOM>\n');
        printf('<FIELDS>ID; LOC; SYNLOC; DE; OS; SEQ; DNA; HGP</FIELDS>\n');
        # entry output
        for j to length(evolution[i]) do
            loc := SearchArray(evolution[i, j, 4], abs(geneR[i]));
            if (geneR[i, loc] < 0) then
                loc := -loc;
            fi;
            printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS><HGP>%d</HGP><SEQ>%s</SEQ>',
                evolution[i, j, 4], loc, evolution[i, j, 3], 
                evolution[i, j, 5], evolution[i, j, 7], evolution[i, j, 2]);
            if substModels[evolution[i,j,9]][Type] <> 'aa' then
                printf('<DNA>%s</DNA>', evolution[i, j, 6]);
            fi:
            printf('</E>\n'):
        od;
        OpenWriting(previous);
    od;
    lprint('\n\n.db files written...\n\n');
end:


# FASTA output
DBoutFASTA := proc()
    if length(FileStat(wdir.dbdir)) = 0 then
        TimedCallSystem('mkdir -p '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        for j to length(evolution[i]) do
            OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.aa');
            printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i,
                evolution[i, j, 2]);
            OpenWriting(previous);
            if substModels[evolution[i,j,9]][Type] <> 'aa' then
                OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.dna');
                printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i,
                    evolution[i, j, 6]);
                OpenWriting(previous);
            fi:
        od;
    od;
    lprint('\n\n.fasta files written...\n\n');
end:


# DB output for the ancestral sequences
# 11.12.06/dm
DBoutAnc := proc(organism, parent, child, birth)
    if length(FileStat(wdir.dbAncdir)) = 0 then
        TimedCallSystem('mkdir -p '.wdir.dbAncdir, 2);
    fi;
    orgname := sprintf('SE%i-%i_%f', parent, child, birth);
    OpenWriting(wdir.dbAncdir.orgname.'.db');
    # header output
    printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
    printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
    printf('<SOURCE>sequence simulation</SOURCE>\n');
    printf('<DATE>%s</DATE>\n', date());
    printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
    printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
    printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
    printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
        'Organismus syntheticus_%s</OS>\n', orgname);
    printf('<KINGDOM>Bacteria</KINGDOM>\n');
    printf('<FIELDS>ID; LOC; SYNLOC; DE; OS; SEQ; DNA; HGP</FIELDS>\n');
    # entry output
    for j to length(organism) do
        loc := SearchArray(organism[j, 4], abs(geneR[child]));
        if (geneR[child, loc] < 0) then
            loc := -loc;
        fi;
        printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS><HGP>%d</HGP><SEQ>%s</SEQ>',
            organism[j, 4], loc, organism[j, 3], organism[j, 5], organism[j, 7], organism[j, 2]): 
        if substModels[organism[j,9]][Type] <> 'aa' then
            printf('<DNA>%s</DNA>', organism[j, 6]);
        fi:
        printf('</E>\n'):
    od;
    OpenWriting(previous);
end:

# create the real MSA for gene cluster cls.
CreateRealMSA := proc(cls, evol)
    global substModels:
    if length(cls) = 0 then
        return():
    fi:
    simType := substModels[evol[cls[1,1],cls[1,2], 9]][Type]:
    blockSize := substModels[evol[cls[1,1],cls[1,2], 9]][Blocksize]:
    # gather sequences and events
    insertions := [seq([], length(cls))]:
    seqs := [seq([seq(0,3)], length(cls))]:
    seqInd := If(simType = 'aa', 2, 6):
    for i to length(seqs) do
        seqs[i,1] := cls[i,1]:
        seqs[i,2] := evol[cls[i,1], cls[i,2], 4]:
        seqs[i,3] := copy(evol[cls[i,1], cls[i,2], seqInd]):
        events := sort(evol[cls[i,1], cls[i,2], 8], EventOrder):
        for j to length(events) do
            if events[j,2] = 'D' then # deletion
                #printf('i: %d, j: %d, length(seqs): %d, length(events): %d\n', i, j, length(seqs), length(events)):
                #dprint(seqs[i,3]):
                #printf('events[j]: %A\n', events[j]):
                seqs[i, 3] := seqs[i, 3, 1..events[j,3]-1].CreateString(events[j,4], '_').seqs[i, 3, events[j,3]..-1]:
                for k to length(insertions[i]) do
                    if events[j,3] <= insertions[i,k,3] then
                        insertions[i,k,3] := insertions[i,k,3] + events[j, 4]:
                    fi:
                od:
            else # insertion
                insertion := seqs[i,3, events[j,3]+1..events[j,3]+events[j,4]]:
                insertions[i] := append(insertions[i], [events[j,1], i, events[j,3], insertion]):
                seqs[i,3] := seqs[i,3,1..events[j,3]].seqs[i,3,events[j,3]+events[j,4]+1..-1]:
            fi:
        od:
    od:
    
    # combine insertion events
    insertions := sort([seq(op(insertions[i]),i=1..length(insertions))], x->x[1]):
    insertionSets := []:
    insertionSets := append(insertionSets, [insertions[1,1], [insertions[1,2]], insertions[1,3], [insertions[1,4]]]):
    i := 2:
    j := 1:
    while i <= length(insertions) do
        if (insertions[i,1] = insertionSets[j,1]) and (insertions[i,3] = insertionSets[j,3])
                and (length(insertions[i,4]) = length(insertionSets[j,4,1])) then
            insertionSets[j,2] := append(insertionSets[j,2], insertions[i,2]):
            insertionSets[j,4] := append(insertionSets[j,4], insertions[i,4]):
        else
            insertionSets := append(insertionSets, [insertions[i,1], [insertions[i,2]], insertions[i,3], [insertions[i,4]]]):
            j := j + 1:
        fi:
        i := i + 1:
    od:
    insertions := insertionSets:
    
    # re-insert insertions into alignment
    for i to length(insertions) do
        for j to length(seqs) do
            k := SearchArray(j, insertions[i,2]):
            if k > 0 then
                seqs[j,3] := seqs[j,3,1..insertions[i,3]].insertions[i,4,k].seqs[j,3,insertions[i,3]+1..-1]:
            else
                seqs[j,3] := seqs[j,3,1..insertions[i,3]].CreateString(length(insertions[i,4,1]),'_').seqs[j,3,insertions[i,3]+1..-1]:
            fi:
        od:
    od:
    
    # print alignment
    if simType <> 'aa' then
        OpenAppending(wdir.'MSAs.dna'):
    else
        OpenAppending(wdir.'MSAs.aa'):
    fi:
    for i to length(seqs) do
        printf('SE%03d/%05d\t%s\n', seqs[i,1],seqs[i,2],seqs[i,3]):
    od:
    printf('\n\n'):
    OpenWriting(previous):
    if simType <> 'aa' and blockSize = 3 then
        OpenAppending(wdir.'MSAs.aa'):
        for i to length(seqs) do
            curseq := '':
            for j to length(seqs[i,3]) by 3 do
                if seqs[i, 3, j..j+2] = '___' then
                    curseq := curseq.'_':
                else
                    curseq := curseq.CodonToA(seqs[i, 3, j..j+2]):
                fi:
            od:
            printf('SE%03d/%05d\t%s\n', seqs[i,1],seqs[i,2],curseq):
        od:
        printf('\n\n'):
        OpenWriting(previous):
    fi:
end:

EventOrder := proc(a, b)
    if a[1] > b[1] then return(true):
    elif a[1] = b[1] and (a[2] = 'D' or b[2] = 'I') then
        return(true):
    else
        return(false):
    fi:
end:

# creates gene trees for an array of gene clusters
# parameters:
#   clsts: array of gene clusters, where each cluster consists of a list of organism/gene tupels
#   evol:  the evolution data structure.
#   msteps: the maximum number of simulation steps (for defining the depth of the leaves
CreateGeneTrees := proc(clsts, evol, msteps, lheights)
    # create output directory for gene trees
    CallSystem('mkdir '.wdir.'/GeneTrees/'):
    trees := []:
    geneIDs := [seq(transpose(evol[i])[4], i=1..length(evol))]:
    
    # loop over all clusters
    for c to length(clsts) do
#        printf('cluster %d\n', c):
        cls := sort(clsts[c],x->x[1]):
        
        # create a list of leaf nodes containing for each node the org/gene id of the current gene as well
        # as its parent and the time of the event.
        # the list will contain nodes that have been deleted during evolution
        nodes := {}:
        for i to length(cls) do
            if evolution[cls[i,1], cls[i,2], 3] = '1' then
                nodes := append(nodes, [cls[i,1], evolution[cls[i,1], cls[i,2], 4], 0, evolution[cls[i,1], cls[i,2], 4], 0]):
            else
                gid := evolution[cls[i,1], cls[i,2], 4]:
                k := length(evolution[cls[i,1], cls[i,2], 3]):
                j := k:
                while j <> 1 and evolution[cls[i,1], cls[i,2], 3, j] <> ')' do j := j - 1: od:
                do
                    while j <> 1 and evolution[cls[i,1], cls[i,2], 3, j - 1] <> ')' do j := j - 1: od:
                    do
                        curg := sscanf(evolution[cls[i,1], cls[i,2], 3, j..k], '%d-%d(%dL%g)%d'):
                        if length(curg) = 5 then
                            # LGT
                            nodes := append(nodes, [curg[5], gid, curg[2], curg[3], curg[4], 'L']):
                            gid := curg[3]:
                            break:
                        fi:
                        curg := sscanf(evolution[cls[i,1], cls[i,2], 3, j..k], '%d-%d(%dLo%g)%d'):
                        if length(curg) = 5 then
                            # LGT orthologous replacement
                            nodes := append(nodes, [curg[5], gid, curg[2], curg[3], curg[4], 'Lo']):
                            gid := curg[3]:
                            break:
                        fi:
                        curg := sscanf(evolution[cls[i,1], cls[i,2], 3, j..k], '%d-(%dD%g)%d'):
                        if length(curg) = 4 then
                            # duplication
                            nodes := append(nodes, [curg[4], gid, curg[4], curg[2], curg[3], 'D']):
                            gid := curg[2]:
                            break:
                        fi:
                        curg := sscanf(evolution[cls[i,1], cls[i,2], 3, j..k], '%d-(%g)%d'):
                        if length(curg) = 3 then
                            # speciation
                            nodes := append(nodes, [curg[3], gid, curg[1], gid, curg[2], 'S']):
                            break:
                        fi:
                        error('unknown format: %s', evolution[cls[i,1], cls[i,2], 3, j..-1]):
                    od:
                    if j = 1 then
                        nodes := append(nodes, [1, gid, 0, gid, 0]):
                        break:
                    fi:
                    k := j:
                    while evolution[cls[i,1], cls[i,2], 3, k+1] <> '-' do k := k + 1: od:
                    j := j - 1:
                od:
            fi:
        od:
    
        # sort nodes by time and insert them into a tree
        nodes := sort([op(nodes)], x->x[5]):
        tree := Leaf(sprintf('SE%03d_%d', nodes[1,1], nodes[1,2]), msteps):
        gind := SearchArray(nodes[1,2], geneIDs[nodes[1,1]]):
        nodes[1] := [nodes[1,1], If(gind = 0, nodes[1,2], gind)]:
        for i from 2 to length(nodes) do
            tree := InsertNode(tree, nodes[i], msteps);
            gind := SearchArray(nodes[i,2], geneIDs[nodes[i,1]]):
            nodes[i] := [nodes[i,1], If(gind = 0, nodes[i,2], gind)];
        od:
        
        # remove genes that were lost during evolution
        remnodes := {op(nodes)} minus {op(cls)}:
        for i to length(remnodes) do
            tree := RemoveNode(tree, sprintf('SE%03d_%d', remnodes[i,1], remnodes[i,2])):
        od:
        
        # correct leaf heights
        tree := CorrectLeafHeights(tree, lheights):
        
        # store tree
        OpenWriting(wdir.'/GeneTrees/GeneTree'.c.'.drw'):
        printf('tree_%d := %A\n\n', c, tree):
        OpenWriting(previous):
        if not type(tree, Leaf) then
            DrawTree(tree):
            CallSystem('mv temp.ps '.wdir.'/GeneTrees/GeneTree'.c.'.ps'):
        fi:
        trees := append(trees, tree):
    od:
    return(trees):
end:

# insert a new leaf node n into tree t. The method assumes that n is younger than all current
# leaves of the tree. Hence, the insertion is reduced to combining an existing leaf with the one
# being inserted into an inner node.
InsertNode := proc(t:Tree, n:list, msteps) option internal;
    if type(t, Leaf) then
        if t[Label] = sprintf('SE%03d_%d', n[3], n[4]) then
            return(Tree(t, n[5], Leaf(sprintf('SE%03d_%d', n[1], n[2]), msteps), n[6])):
        else
            return(NULL):
        fi:
    else
        r := InsertNode(t[Left], n, msteps):
        if r <> NULL then
            t[Left] := r:
            return(t):
        fi:
        r := InsertNode(t[Right], n, msteps):
        if r <> NULL then
            t[Right] := r:
            return(t):
        fi:
        return(NULL):
    fi:
end:

# remove leaf node with label l from tree t.
RemoveNode := proc(t:Tree, l:string) option internal:
    if type(t, Leaf) then
        if t[Label] = l then
            return(NULL):
        fi:
    else
        if type(t[Right], Leaf) then
            if t[Right, Label] = l then
                return(t[Left]):
            fi:
        fi:
        if type(t[Left], Leaf) then
            if t[Left, Label] = l then
                return(t[Right]):
            fi:
        fi:
        if not type(t[Right], Leaf) then
            t[Right] := RemoveNode(t[Right], l):
        fi:
        if not type(t[Right], Leaf) then
            t[Left] := RemoveNode(t[Left], l):
        fi:
    fi:
    return(t):
end:

CorrectLeafHeights := proc(tree:Tree, lheights:list)
    if type(tree, Leaf) then
        tokens := sscanf(tree[Label], 'SE%03d_%d'):
        tree[Height] := lheights[tokens[1]]:
    else
        tree[Left] := CorrectLeafHeights(tree[Left], lheights):
        tree[Right] := CorrectLeafHeights(tree[Right], lheights):
    fi:
    return(tree):
end:

WriteOrthologs := proc(trees, norgs)
    VPs := CreateArray(1..norgs, 1..norgs, []):
    
    for i to length(trees) do
        curt := trees[i]:
        GetOrthologs(curt, VPs):
    od:
    
    OPs := CreateArray(1..norgs, 1..norgs, []):
    PPs := CreateArray(1..norgs, 1..norgs, []):
    XPs := CreateArray(1..norgs, 1..norgs, []):
    for i to norgs do
        for j to norgs do
            for n to length(VPs[i,j]) do
                if VPs[i,j,n, 3] = 'S' then
                    OPs[i,j] := append(OPs[i,j], VPs[i,j,n,1..2]):
                elif VPs[i,j,n, 3] = 'D' then
                    PPs[i,j] := append(PPs[i,j], VPs[i,j,n,1..2]):
                else
                    XPs[i,j] := append(XPs[i,j], VPs[i,j,n,1..2]):
                fi:
            od:
        od:
    od:
    
    # store orthologs, paralogs and xenologs in separate files
    CallSystem('mkdir '.wdir.'/VP'):
    for i to norgs do
        CallSystem('mkdir '.wdir.sprintf('/VP/SE%03d', i)):
        for j to norgs do
            OpenWriting(wdir.sprintf('/VP/SE%03d/SE%03d.op', i, j)):
            printf('OP := %A\n', OPs[i,j]):
            OpenWriting(previous):
            OpenWriting(wdir.sprintf('/VP/SE%03d/SE%03d.pp', i, j)):
            printf('PP := %A\n', PPs[i,j]):
            OpenWriting(previous):
            OpenWriting(wdir.sprintf('/VP/SE%03d/SE%03d.xp', i, j)):
            printf('XP := %A\n', XPs[i,j]):
            OpenWriting(previous):
        od:
    od:
end:

GetOrthologs := proc(t:Tree, VPs:list(list(list))) option internal:
    if type(t, Leaf) then return(NULL): fi:

    norgs := length(VPs):
    curgl := CreateArray(1..norgs, []):
    curgr := CreateArray(1..norgs, []):
    lleaves := [GetTreeLabels(t[Left])]:
    rleaves := [GetTreeLabels(t[Right])]:
    for i to length(lleaves) do
        o := atoi(lleaves[i,3..5]):
        g := atoi(lleaves[i,7..-1]):
        curgl[o] := append(curgl[o], g):
    od:
    for i to length(rleaves) do
        o := atoi(rleaves[i,3..5]):
        g := atoi(rleaves[i,7..-1]):
        curgr[o] := append(curgr[o], g):
    od:
    for i to norgs do
        if curgl[i] = [] then next fi:
        for j from i+1 to norgs do
            if curgr[j] = [] then next fi:
            VPs[i, j] := append(VPs[i,j], [curgl[i], curgr[j], t[xtra]]):
            VPs[j, i] := append(VPs[j,i], [curgr[j], curgl[i], t[xtra]]):
        od:
        VPs[i, i] := append(VPs[i,i], [curgl[i], curgr[i], t[xtra]]):
    od:

    GetOrthologs(t[Left], VPs):
    GetOrthologs(t[Right], VPs):

    NULL:
end:

ReadTreeFile := proc(fileName:string)
    tree := ReadRawFile(fileName):
    if tree[1..4] = 'Tree' then
        # assume darwin format
        t := traperror(parse(tree)):
        if t = lasterror then
            error('could not parse tree. assumed tree in darwin format, but encountered an error: '.lasterror):
        fi:
    elif tree[1..4] = 'Leaf' then
        error('tree must consist of more than just a leaf'):
    else
        #assume newick format
        t := traperror(ParseNewickTree(tree, 'InternalLabels'=ReadNewickAnnotation)):
        if t = lasterror then
            error('could not parse tree. assumed tree in newick format but encountered an error: '.lasterror.'. make sure to include branch lengths in the tree description.'):
        fi:
    fi:
    t
end:

ReadNewickAnnotation := proc(label:string)
    if label = NULL or label = '' then
        return(NULL);
    elif label[1] = '''' and label[-1] = '''' then
        procname(label[2..-2]);
    elif label[1] = 'S' or label[1] = 'D' then
        tokens := SearchDelim('_', label[2..-1]);
        models := []:
        for i to length(tokens) do
            curmodel := SearchDelim('-', tokens[i]):
            if length(curmodel) <> 2 or atoi(curmodel[1]) = 0 or atoi(curmodel[2]) = 0 then
                error('could not parse model');
            fi:
            models := append(models,[atoi(curmodel[1]), atoi(curmodel[2])]):
        od:
        models := sort(models, x->x[1]):
        return([label[1], models]);
    else
        error('internal node names should have the format <event>_<model> (e.g. S1 or D2)'):
    fi:
end:


lprint('IO procedures for Synthetic Evolution sucessfully loaded');
