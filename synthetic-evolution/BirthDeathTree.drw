BirthDeathTree := proc(b, d; (timeStop=0):nonnegative, (taxaStop=0):nonnegative, (returnAllExtinct=true):boolean)
    # creates a birth-death tree with parameters b and d. Simulation continues until either the
    # maximum simulation time is reached or the number of living species hits the defined maximum
    # (use 0 for either max. time or species to discard it).
    # This procedure is a darwin-port of the R procedure birthdeath.tree by Jason T. Weir and
    # Luke J. Harmon, which is part of the bdtree package.
    #
    # Returns an ultrametric tree, including dead lineages.
    if timeStop=0 and taxaStop=0 then
        error('Must have stopping criterion\n');
    fi:
    
    do    
        edge := copy([[1, 2], [1, 3]]): # this is a starting edge matrix
        edgeLength := [seq(NA, 2)]:
        stemDepth := [seq(0, 2)]:
        alive := [seq(1, 2)]: # marker for live lineages
        t := 0.0: #time at any point in the tree
        nextNode := 4:
        
        do
            if taxaStop <> 0 and sum(alive) >= taxaStop then break; fi:
            if sum(alive) = 0 then break; fi:
            dt := Rand(Exponential(0, 1/(sum(alive)*(b+d))));
            t := t + dt;
            #printf('current time: %g\n', t):
            if timeStop <> 0 and t >= timeStop then
                t := timeStop;
                break;
            fi:
            random_lineage := round(Rand()*(sum(alive)-1)+1):
            e := []:
            for i to length(alive) do
                if alive[i] = 1 then
                    e := append(e, i):
                fi:
            od:
            r := Rand():
            if r <= b / (b + d) then ###4 #this creates a bifucation in the tree
                parent := edge[e[random_lineage],2]:
                alive[e[random_lineage]] := 0:
                edge := append(edge, [parent, nextNode], [parent, nextNode+1]):
                nextNode := nextNode+2:
                alive := append(alive, 1, 1):
                stemDepth := append(stemDepth, t, t):
                edgeLength[e[random_lineage]] := t-stemDepth[e[random_lineage]]:
                edgeLength := append(edgeLength, NA, NA):
            else ###4 This terminates one of the current lineages on the tree
                edgeLength[e[random_lineage]] := t-stemDepth[e[random_lineage]]:
                alive[e[random_lineage]] := 0:
                #printf('edge %i is dead\n', e[random_lineage]):
            fi:###4
        od:#1A
        
        if returnAllExtinct or sum(alive)>1 then break; fi:
    od:

    for i to length(alive) do
        if alive[i] = 1 then
            edgeLength[i] := t - stemDepth[i]:
        fi:
    od:
    
    n := -1:
    #printf('min: %d, max: %d\n', min(edge), max(edge)):
    me := max(edge):
    for i to me do
        found := false:
        for j to length(edge) do
            if edge[j,1] = i then
               found := true:
                edge[j, 1] := n:
            fi:
        od:
        if found then
            for j to length(edge) do
                if edge[j, 2] = i then
                    edge[j, 2] := n:
                fi:
            od:
            n := n-1:
        fi:
    od:
    
    n := 1:
    
    for i to length(edge) do
        if edge[i,2] > 0 then
            edge[i, 2] := n:
            n := n+1:
        fi:
    od:
   
    #printf('alive: %a\n', alive):
    
    # build tree structure
    tree := Tree(BuildBDTree(edge, edgeLength, alive, 0), 0, BuildBDTree(edge[2..-1], edgeLength[2..-1], alive [2..-1], 0)):
end:

# Helper function for (recursively) building a tree structure from the edge matrix and edge length vector
# computed in BirthDeathTree.
# invariant: edge at index 1 ends in current node
BuildBDTree := proc(edgeMat, edgeLen, alive, parHeight)
    if edgeMat[1,2] > 0 then
        if alive[1] = 1 then
            res := Leaf(string(edgeMat[1,2]), parHeight+edgeLen[1]):
        else
            res := Leaf('D'.edgeMat[1,2], parHeight+edgeLen[1]):
        fi:
    else
        for i from 2 to length(edgeMat) do
            if edgeMat[i,1] = edgeMat[1,2] then
                n := i:
                break:
            fi:
        od:
        subtree1 := BuildBDTree(edgeMat[n..-1], edgeLen[n..-1], alive[n..-1], parHeight+edgeLen[1]):
        subtree2 := BuildBDTree(edgeMat[n+1..-1], edgeLen[n+1..-1], alive[n+1..-1], parHeight+edgeLen[1]):
        res := Tree(subtree1, parHeight+edgeLen[1], subtree2):
    fi:
    res
end:

# Helper function for getting a list of all surviving lineages in the BD-Tree
ListLivingLineages := proc(tree:Tree)
    if type(tree, Leaf) then
        if tree[Label,1] = 'D' then
            res := []:
        else
            res := [tree[Label]]:
        fi:
    else
        res := append(ListLivingLineages(tree[Left]), op(ListLivingLineages(tree[Right]))):
    fi:
    res
end:

FindDeepestLeaf := proc(tree:Tree)
    if type(tree, Leaf) then
        res := tree[Height]:
    else
        t1 := FindDeepestLeaf(tree[Left]):
        t2 := FindDeepestLeaf(tree[Right]):
        res := max(t1,t2):
    fi:
    res
end:

ScaleTreeHeight := proc(tree:Tree, factor:float)
    tree[Height] := tree[Height] * factor:
    if not type(tree, Leaf) then
        ScaleTreeHeight(tree[Left], factor):
        ScaleTreeHeight(tree[Right], factor):
    fi:
end:

ScaleTree := proc(tree:Tree, height:float)
    curh := FindDeepestLeaf(tree):
    hfac := height / curh:
    ScaleTreeHeight(tree, hfac):
end:

ListTimePoints := proc(tree:Tree, prefix:string)
    if type(tree, Leaf) then
        res := copy([[],[]]):
    else
    	lt := ListTimePoints(tree[Left], prefix.'.1'):
    	rt := ListTimePoints(tree[Right], prefix.'.2'):
    	if length(tree) = 4 then
    		if tree[xtra][1] = 'S' then
	    		res := [[[prefix, tree[Height], tree[xtra][2]], op(lt[1]), op(rt[1])], [op(lt[2]), op(rt[2])]]:
	    	else
	    		res := [[op(lt[1]), op(rt[1])], [[prefix, tree[Height], tree[xtra][2]], op(lt[2]), op(rt[2])]]:
	    	fi:
   		else
	        res := [[[prefix, tree[Height]], op(lt[1]), op(rt[1])],[]]:
	    fi:
    fi:
    res
end:
    
EnumerateBranches := proc(tree:Tree, specPts)
	branches := append(EnumerateBranches_R(tree[Left], tree[Height]), op(EnumerateBranches_R(tree[Right], tree[Height]))):
	branches := sort(branches, x->x[1]):
	res := []:
	n := 2:
	for i to length(specPts) do
		res := append(res, [specPts[i, 1], op(branches[2*i-1])], [n, op(branches[2*i])]):
		n := n + 1:
	od:
	res
end:

EnumerateBranches_R := proc(tree:Tree, start:nonnegative)
	if type(tree, Leaf) then return([[start, tree[Height]]]): fi:
	
	res := EnumerateBranches_R(tree[Left], tree[Height]):
	res := append(res, [start, tree[Height]], op(EnumerateBranches_R(tree[Right], tree[Height]))):
end:


### old procedures ###
#Species := proc(name:string, descendent1:Species, descendent2:Species, speciationTime:integer) option polymorphic;
#    noeval(procname(args));
#end:

#Species_type := noeval({structure(anything,Species),structure(anything,NullSpecies)}):

#NullSpecies := proc() option polymorphic;
#  noeval(NullSpecies(args))
#end:
#NullSpecies_type := noeval(structure(anything,NullSpecies)):

#BDProcOld := proc(s:Species, lambda:float, mu:float, remTime:nonnegative, maxsim:posint)
#    for i to remTime do
#        r := Rand():
#        if r < lambda then
#            s1 := Species(s[name].'-1', NullSpecies(), NullSpecies(), 0):
#            s[descendent1] := s1:
#            BDProc(s[descendent1], lambda, mu, remTime-i, maxsim):
#            s2 := Species(s[name].'-2', NullSpecies(), NullSpecies(), 0):
#            s[descendent2] := s2:
#            BDProc(s[descendent2], lambda, mu, remTime-i, maxsim):
#            s[speciationTime] := maxsim-remTime+i:
#            break:
#        elif r < lambda + mu then
#            s[name] := s[name].'-T':
#            s[speciationTime] := maxsim-remTime+i:
#            break:
#        fi:
#    od:
#    if i = remTime+1 then
#        s[speciationTime] := maxsim:
#    fi:
#end:

#BuildBDTreeOld := proc(s:Species)
#    resTree := subTree1 := subTree2 := NULL:
#    if type(s[descendent1], NullSpecies) and type(s[descendent2], NullSpecies) then
#        if s[name,-1] <> 'T' then
#            resTree := Leaf(s[name], s[speciationTime]):
#        fi:        
#    else
#        if not type(s[descendent1], NullSpecies) then
#            subTree1 := BuildBDTree(s[descendent1]):
#        fi:
#        if not type(s[descendent2], NullSpecies) then
#            subTree2 := BuildBDTree(s[descendent2]):
#        fi:
#    fi:
#    if subTree1 <> NULL and subTree2 <> NULL then
#        resTree := Tree(subTree1, s[speciationTime],subTree2):
#    elif subTree1 <> NULL then
#        resTree := subTree1:
#    elif subTree2 <> NULL then
#        resTree := subTree2:
#    fi:
#    resTree
#end:

#BirthDeathTreeOld := proc(lambda, mu, maxsim:posint)
#    SetRandSeed():
    
#    first := Species('1', NullSpecies(), NullSpecies(), 0):
    
#    BDProc(first, lambda, mu, maxsim, maxsim):
#    first;
#end:
